!!com.ec.upgrade.ecconfig.model.ConfigurationItemGroup
fileName: '-27198485'
keys:
  BF_DESCRIPTION_NO: CO.1037
  DATA_LEVEL: 0.0
  T: BF_DESCRIPTION
parentKeys: {}
properties:
  BF_DESCRIPTION_NO: CO.1037
  BUSINESS_FUNCTION_NO: (SELECT BUSINESS_FUNCTION_NO FROM BUSINESS_FUNCTION WHERE URL ='/com.ec.frmw.bs.calc.screens/db_object_type' )
  DATA_LEVEL: 0.0
  DESCRIPTION: <p>The Database Object Types screen is used to map various EC objects for use in the calculation engine. Database Object Types are defined for each <em>Calculation Context (CO.1036)</em>.</p><h4><em>Object Types</em></h4><p>Object types are used by the calculation engine to build sets of objects that should all be treated in the same way, and to access data on these objects. The Database Object Types screen is used to tell the calculation engine which EC classes that will be used for these purposes. Normally the list of object types that are needed can be found by analysing the data, and realising that an object type is needed for each EC class that</p><p></p><ul><li>Is the Owner class of any used data. Typical examples are the main data carrying objects like Wells, Streams, Contracts, etc.</li><li>Is used as additional dimensions on data. Typical examples are components, companies, delivery points, etc.</li><li>Is used to help structure the data and/or calculations. Typical examples are nodes, contract areas, etc.</li></ul><p></p><p>See also the documentation for the BF <em>Variable Definitions (CO.1039)</em> for more information on how the object types are used when they are the owner of or a dimension on data.</p><p>The Database Object Types screen is only used to define object types where the objects are configured in the EC database. These are normally objects from Object or Interface classes although other type of classes are sometimes used. In some cases there are concepts that are used in the same way as object types (e.g. dimensions on data) but that doesn’t have a clear representation as a class in EC. These are defined in a separate BF, <em>Simple Object Types (CO.1038)</em>.</p><h4><em>Attributes</em></h4><p>One of the most common ways of using objects in calculations is to build sets of objects that should be treated the same way, as these can then be processed more efficiently. The most common way to build such sets is to base it on the attributes of the objects</p><p>Since each object type is based on an EC class, the attributes could simply be found from the Class Attributes and Class Relations. However, the screen instead requires that each attribute to be used must be clearly defined, and then mapped to the actual class attribute (or relation) that it corresponds to. This approach might seem a bit cumbersome but has several advantages:</p><p></p><ul><li>This approach reduces the number of attributes in dropdowns in the calculation screens, as it is normally only a small subset of the class attributes that are actually used for calculation purposes.</li><li>It is possible to use a different label then the often screen–centric label defined on the class attribute.</li><li><p>Separating the mapping from the definition of the attribute means that it is possible to have different mappings for different implementing classes in an interface, and that it is possible to map attributes that are not actually part of the interface itself.</p><p>To facilitate this, it is possible to select the level where the mapping should be done for interfaces; either at the main level or for each implementing class</p></li><li>By allowing the attribute to be first defined and then later mapped to an attribute, it is easier to start designing and writing calculations even if it is not decided yet exactly how the data mapping will be.</li></ul><p></p><h4><em>Filtering</em></h4><p>When a calculation makes use of an object, the calculation engine will normally read all objects of that type into memory and make them available for the calculation. There are some reasons why one might want to add some additional filtering to limit the list of objects to read:</p><p></p><ul><li>If there are many objects then it makes sense from a performance point of view to limit the amount of objects read to those that are really necessary.</li><li>The calculation engine also uses the object filtering indirectly to filter the data being read, which gives an even larger impact on performance.</li><li>Calculations are often set up to work sets of objects through set definitions. It is easier to define these sets if one can assume that irrelevant objects have already been filtered out when the objects are loaded.</li></ul><p></p><p>Normally it would be the main business and data carrying objects that are filtered, and normally the filtering is based either on knowledge the implementer has of the data usage or on an input parameter provided by the user when the calculation is run.</p><p>The screen supports three main types of filtering:</p><p></p><ul><li>It is possible to exclude certain implementing classes when using an interface class. This is useful to exclude classes that implement the interface but are irrelevant to calculations, at least in the current calculation context.</li><li>It is possible to filter objects based on an attribute matching a screen parameter. This is most commonly used when the user is allowed to select a single object to calculate from the screen. This could be through a direct choice in a dropdown or similar, for example selecting a single Contract in the navigator in the Contract Calculation screens. It could also be more indirectly, for example running a Load or Unload calculation for a cargo indirectly selects a single relevant Storage object.</li><li>It is possible to filter objects based on an attribute having a more indirect relation to a screen parameter. These more advanced filters include filtering based on calculation collections (allocation networks, contract groups, etc).</li></ul><p></p>
related: {}
