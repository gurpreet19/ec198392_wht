!!com.ec.upgrade.ecconfig.model.ConfigurationItemGroup
fileName: '-1307062163'
keys:
  BF_DESCRIPTION_NO: CO.1039
  DATA_LEVEL: 0.0
  T: BF_DESCRIPTION
parentKeys: {}
properties:
  BF_DESCRIPTION_NO: CO.1039
  BUSINESS_FUNCTION_NO: (SELECT BUSINESS_FUNCTION_NO FROM BUSINESS_FUNCTION WHERE URL ='/com.ec.frmw.bs.calc.screens/variable_definition' )
  DATA_LEVEL: 0.0
  DESCRIPTION: |
    <p>The Variable Definitions screen is used to map data in the EC database for use in the calculation engine. Variables are defined for each <em>Calculation Context (CO.1036)</em>.</p>

    <h4><em>Variables</em></h4>

    <p>Variables are used by the calculation engine to represent data elements. All formulas in a calculation use variables to get the input data and store the result of the calculation. As a very simple example, the formula X = Y + 2 will reference the value of the variable Y, add the constant 2 and assign the result to the variable X.</p>

    <p>This will overwrite any existing value of the variable X.</p>

    <p>There are three main types of variables:</p>
    <p>
    <ul>
    <li>Variables that represents data to be read from or stored to the EC database; these have at least one Read Mapping or Write Mapping.</li>
    <li>Variables that hold intermediate results and are used by several calculation.</li>
    <li>Variables that hold intermediate results and are only used by one (or part of one) calculation.</li>
    </ul>
    </p>

    <p>Only the first two types are defined in the <em>Variable Definitions</em> screen; the last type is defined together with the relevant calculation in the BF <em>Maintain Calculation (CO.1040)</em>.</p>

    <p>As an important note, variables that are read from the database will only be read once. This value can be overwritten by subsequent formulas, and any later references to the variable will retrieve the latest assigned value. Similarly a variable that is stored back to the database can be assigned several values during the execution of a calculation, but only the last value assigned will be written back to the database.</p>

    <p>It is possible to initially define the variable without any read or write mappings, and add these later. This is useful in early stages of an implementation when the exact knowledge of where to read or store a certain data element is not yet known. The variable will then act as a holder of intermediate results until a mapping is added. Additional formulas can then temporarily be added to the calculation(s) to initialise and/or output the values of the variable during early development and testing.</p>

    <h4><em>Variable Dimensions</em></h4>

    <p>In many of the typical calculations performed in EC, it useful to have dimensions on data variables. To better understand this, consider the three main types of dimensions:</p>
    <p>
    <ul>
    <li>
    <p>Date dimensions</p>
    <p>As an example, a monthly calculation might need to work with daily data for each day in the month. In this case it makes sense to index the data by day. So for example, instead of a variable called OilProduction that only holds a single value, it would make more sense to have a variable that can hold the oil production for each day in the month. This is similar to a table structure or range of cells in e.g. Excel, except that in EC this can be defined as a single variable with a dimension of type Day. This is denoted with subscripts or square brackets, OilProduction[Day].</p>
    </li>
    <li>
    <p>Owner dimensions</p>
    <p>The owner of a data element is the object the data &ldquo;belongs&rdquo; to. For example, oil production for a given well is a data element &ldquo;owned&rdquo; by the well. To make the system more maintainable, it is often desirable that we design the calculations to work without knowing exactly what all the involved objects are. This way, we don&rsquo;t have to change the calculations every time e.g. a new well is added to the system.</p>
    <p>For this to be possible, however, we need the variables to also work dynamically with the objects actually in the system and not be &ldquo;linked&rdquo; (directly or indirectly) to a given object.</p>
    <p>So instead of having the variables OilProductionWell1 and OilProductionWell2, we should rather define a single variable but have the owner object type as dimension. In our example the variable would then be OilProduction[Well].</p>
    </li>
    <li>
    <p>Additional dimensions</p>
    <p>Related to the owner dimensions, this type of dimensions is typically also used to increase maintainability by not making assumptions on the objects present in the system. The two most common additional dimensions are Components (in mass/component based allocations) and various ownerships dimensions (Company, Profit Centre, Lifting Accounts etc). But other dimensions are also used for various purposes.</p>
    </li>
    </ul>
    </p>

    <p>The different types of dimensions are frequently combined to form multi&ndash;dimensional variables. A typical example could be OilProduction[Well, Day, Component] which is then used to store the production for each well broken down to each component, and for each day of the month.</p>

    <p>One of the main benefits of defining variable dimensions is that EC can efficiently process data for many objects in one equation. Typical examples include:</p>
    <p>
    <ul>
    <li>For a date indexed variable, all days in the month (or similar) can be processed by a single equation.</li>
    <li>For an object indexed variable, all or a subset of objects can be processed by a single equation (if they should be treated the same way).</li>
    <li>It is easy to aggregate across dimensions etc.</li>
    </ul>
    </p>

    <p>For this to be possible, the calculation engine uses object sets and iterations in the formula definitions. This again requires that all variable dimensions are defined as object types. For more information about object sets, see the BF <em>Maintain Calculation (CO.1040)</em>. For more information on object types and how they are defined, see the BFs <em>Database Object Types (CO.1037)</em> and <em>Simple Object Types (CO.1038)</em>.</p>

    <p>Also please note that the object type for a dimension is not the same as the object type of the variable value itself. The object type of a variable is only used in the rare cases where the value of a variable is actually an object, which is again used to access data in other variables.</p>

    <h4><em>Class Mappings</em></h4>

    <p>If a variable is to be read from or stored to the EC database, then the calculation engine needs to know the details on where in the database the data is stored. This is done by linking the variable to one or more EC Data Classes. This is done through Read Mappings (to read data from the database) and Write Mappings (to store data back to the database). Note that the same variable can have both a read and a write mapping, but in this case special care must be taken to make sure that the expected value is being written back as the calculations could change the value after it is read but before it is written.</p>

    <p>In some special cases a variable could have more than one read (or write) mapping:</p>
    <p>
    <ul>
    <li>In some parts of the EC product there is support for using the same calculation on different data sets. The most common examples are related to forecasting and dispatching calculations, where the same calculations are applied to forecasted, expected and actual data. In this case there should be different mappings for each relevant data set.</li>
    <li>In many cases the variable owner dimensions are actually interface class based object types. This means that object types that are seen as one type from the calculation engine&rsquo;s point of view are actually based on several different but closely related object classes. A very common example is the concept of an Allocation Node, which normally consists of several object classes like Well, Storage, Facility etc. In this case there could be different data classes used to store the data for each underlying object class. This would require different mappings for each such data class.</li>
    </ul>
    </p>

    <h4><em>Class Key Mappings</em></h4>

    <p>Once the mapping to one or more data classes is complete, the engine also needs to know how the class keys should be mapped. The keys of a class are the attributes that uniquely identifies a single data record. It is closely linked to the concept of variable dimensions; the keys of a class are the dimensions of the data as they are stored in the database.</p>

    <p>This is also seen in the key mappings, where the most common case is that there is a one to one relationship between the class keys and the variable dimensions. It is, however, possible to have fewer dimensions on the variable than the number of keys on the class. This is done by mapping these keys to specific value(s).</p>

    <p>Each class key must thus be mapped as one of the following:</p>
    <p>
    <ul>
    <li>
    <p>As a variable dimension.</p>
    <p>This is the most common case, and the screen will automatically try to map keys to dimensions when a new mapping is created.</p>
    </li>
    <li>
    <p>As a specific value, given by screen parameter.</p>
    <p>This includes values that are given by the screen context (typically based on navigator values etc) and values selected directly by the user in a dropdown.</p>
    <p>The most common cases include calculation date, specific owner objects and specific forecast scenarios.</p>
    </li>
    <li>
    <p>As a key to be Ignored.</p>
    <p>This is used if the key is not needed in the read/write statements, and is typically related to columns that are maintained by triggers, or columns that are used to distinguish multiple classes on the same table.</p>
    </li>
    </ul>
    </p>

    <h4><em>Data Validity Periods</em></h4>

    <p>Data that are read from the database are assumed to be valid for a given time period. This affects read performance optimisations and also whether or not the engine will associate a given value with a given date.</p>

    <p>There are three types of validity period settings:</p>
    <p>
    <ul>
    <li>Data valid only for a given timestamp. This is the most common type and includes all data with fixed frequencies, like daily data, monthly data and so on. A data record is only associated with the date it is &ldquo;stamped&rdquo; with.</li>
    <li>Data valid for a period of time, as given by a &ldquo;valid from&rdquo; time and a &ldquo;valid to&rdquo; time (i.e. two timestamps for each data record). This is typically used for event based data.</li>
    <li>Data valid from a given date and until it is replaced by a new value. In this case there is a single &ldquo;valid from&rdquo; time associated with the data, and the value is assumed to remain constant until the next record&rsquo;s valid from time. This is used for certain types of configuration and data that are event based but where the system always use the last available value, like split percentages and similar.</li>
    </ul>
    </p>

    <p>In addition it is necessary to tell the system which of the class keys that represents the time stamp(s) for the data. The screen is normally able to auto&ndash;detect this when a new mapping is created, but it should always be checked for consistency.</p>

    <p>Please note that this information is used only to read data from the database. Any subsequent assignments to the variable, and also any data stored to the database, will always associate the data with timestamps as given by the variable dimensions and class key mappings. In practice this would normally mean either a single time stamp given by a dimension, or that the timestamp is fixed based on a screen parameter.</p>

    <h4><em>Sub&ndash;Daily Data</em></h4>

    <p>If the variable is associated with data that has a higher time frequency than daily data (e.g. hourly data), then the calculation engine needs additional information on how to link the timestamps for the data to days. This is needed because of concepts like &ldquo;production day&rdquo; and &ldquo;contract day&rdquo;, where the hours that make up a &ldquo;day&rdquo; are actually not the hours from midnight to midnight but rather e.g. 06:00 to 06:00.</p>

    <p>All data tables in EC that store such sub&ndash;daily data therefore contains additional time stamp information that links sub&ndash;daily data records to days. In addition there is a flag to differentiate between timestamps within the one&ndash;hour interval each year that exists twice in countries that use daylight savings time.</p>

    <p>For any variables that read or write such data it is therefore necessary to tell the system which attributes in the class that contain this information. The screen is normally able to auto&ndash;detect this when a new mapping is created, but it should always be checked for consistency.</p>

    <h4><em>Other Advanced Settings</em></h4>

    <p>For variables stored back to the database there are some additional settings that can be used in some special cases. These settings are normally used for writing new rows in data classes where one of the class keys is a generated value, e.g. a sequence number.</p>

    <p>A variable can also be flagged as &ldquo;Advanced in editor&rdquo;. This only affects the obsolete BF <em>Maintain Calculation Rule (CO.0095)</em>, and is only there for backwards compatibility reasons.</p>

    <h4><em>Variable Definition Limitations</em></h4>

    <p>Be aware of the following limitations when defining calculation variables:</p>
    <p>
    <ul>
    <li>A single variable should not mix read mappings with data validity period handling of the &ldquo;valid at given time stamp&rdquo; type with read mappings that have either of the &ldquo;valid for a period&rdquo; data validity period types.</li>
    <li>A variable should not have any write mappings if it has a read mapping with one of the &ldquo;valid for a period&rdquo; data validity period types.</li>
    <li>Correspondingly it is not allowed to assign (in calculations) to variables that has a read mapping with one of the &ldquo;valid for a period&rdquo; data validity period types.</li>
    <li>A read mapping should not have the data validity period handling of type &ldquo;Valid Until Next&rdquo; if the variable contains sub&ndash;daily data.</li>
    <li>It is not allowed to mix read or write mappings with sub&ndash;daily and non&ndash;sub&ndash;daily data on the same variable.</li>
    </ul>
    </p>

    <p>Please note that these rules are checked during run&ndash;time, not design time. This also means that the rules in general apply to the variable as it is seen from the runtime point of view, and might therefore not apply to mappings for different data sets etc.</p>
related: {}
