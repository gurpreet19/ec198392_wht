!!com.ec.upgrade.ecconfig.model.ConfigurationItemGroup
fileName: '1794306563'
keys:
  BF_DESCRIPTION_NO: CO.1040
  DATA_LEVEL: 0.0
  T: BF_DESCRIPTION
parentKeys: {}
properties:
  BF_DESCRIPTION_NO: CO.1040
  BUSINESS_FUNCTION_NO: (SELECT BUSINESS_FUNCTION_NO FROM BUSINESS_FUNCTION WHERE URL ='/com.ec.frmw.bs.calc.screens/maintain_calculation' )
  DATA_LEVEL: 0.0
  DESCRIPTION: |-
    <h2><span style="font-size: 13.33px;">INTRODUCTION</span><span style="font-size: 13.33px;"><br></span></h2><h3><span style="font-size: 13.33px;">Calculations</span></h3><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">The Maintain Calculation screen is used to define calculations that can be run by the EC calculation engine. Such calculations are used for many different purposes in different parts of the EC product, but can be roughly divided into three categories:</span></font><font face="Arial, Verdana"><span style="font-size: 13.33px;"><br></span></font></p><ol><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Allocation through an allocation network:<br> This category is typically used for well-back allocations, allocations of ownership and mass balancing of plants, allocations of ownership through pipeline systems and similar. Calculations in this category work on an <em>allocation network</em>, which is basically a set of streams and nodes that represents the underlying infrastructure. Streams represent metering points, pipelines etc and models hydrocarbon flows. Nodes represent processing, commingling etc of hydrocarbons where ownership of incoming or outgoing streams needs to be redetermined. The allocation network can be visualized in the BF <em>Stream Node Diagram (CO.0094)</em>.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Calculations performed on a given object or list of objects:<br> This category includes a broad variety of calculations, like lifting schedule generation and BL/MR calculations in Transport, price and contractual calculations in Sales and similar. These calculations are typically carried out individually for each object, e.g. for each lifting or for each contract.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Simple "on the fly" calculations:<br> The simplest category, these calculations are used to calculate a number when the user saves a screen (or similar). The calculations in this category are typically very simple but are built with the calculation engine to allow projects to override the calculation in a user friendly and robust way.</span></font></li></ol><h3><span style="font-size: 13.33px;">Calculation Types</span></h3><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">In EC there are three different calculation types. By calculation type we mean three different ways to actually define what calculations to run and in which order:</span></font></p><ol><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Equation based calculations:<br> This calculation type uses a special mathematical syntax to express calculations. This mathematical syntax has been developed specifically for the type of calculations typically performed in EC, and is very efficient and dynamic. It is especially well suited for complex calculations involving much data, as it is very compact and can process many data elements with a single equation.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Excel workbook based calculations:<br> This calculation type uses an Excel workbook to express the calculations to be performed, and maps data between EC and the Excel workbook when the calculation is executed. In this approach users can design the calculations in Excel, which is a tool that many users are already familiar with. The main drawback is that Excel is not always a suitable tool for complex calculations involving lots of data.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Calculation Processes (flowchart based calculations):<br> The final type of calculations consist of a flowchart which models the calculation flow and breaks a calculation into smaller, more manageable sub-calculations. This calculation type doesn’t really do anything in itself; it is only used to introduce more structure in a calculation. Each sub-calculation can again be any of the three calculation types, which means that these can be mixed freely within a calculation.</span></font></li></ol><h3><span style="font-size: 13.33px;">Fundamental Calculation Concepts</span></h3><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">Even though calculations in EC have a large range in complexity and are implemented in different ways, they are all built around some common concepts. Understanding the basic concepts behind the calculation engine is crucial to designing and implementing calculations in EC:</span></font></p><ol><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Objects:<br> Transactional data values in EC are typically linked to one or more objects, and the objects are used to access/address each value. For example, each well head pressure value is linked to a specific well. To access/address a well head pressure value, we must identify which well it is linked to. Each daily nomination quantity is linked to a specific contract and a specific delivery point. To access a nomination quantity, we must identify which contract and which delivery point it is linked to. Object attributes are also used for grouping purposes (see Sets). The type of objects to use and their attributes are defined in the BFs <em>Database Object Types (CO.1037)</em> and <em>Simple Object Types (CO.1038)</em>.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Variables:<br> Variables are the calculation engine’s link to the data in the EC database, but are also used to hold intermediate values in a calculation. Variables in EC are typically multi-dimensional. This means that a single variable doesn’t contain a single value, but rather one value for each object, each day etc. This is in clear contrast to e.g. Excel, where each cell holds one and only one value.<br> Most variables in EC have at least two dimensions; owner object and date. Typical examples are oil production for a given well on a given day, price index value for a given price index and month etc. Some variables have additional dimensions. The most typical example is ownership, where data is held for each object, each day and each owner. In allocation network based calculations it is common that the input data has fewer dimensions that the output. The inputs are typically measured values per e.g. metering point and day, while the output is often a value per disposal point, day and owner. Variables are defined in the BF <em>Variable Definitions (CO.1039)</em> as well as in the Maintain Calculation BF itself.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Sets:<br> A set is really just a group of objects, and can be anything from the predefined set <em>objects</em>, which contains all objects known to the calculation engine, to sets that only include a single object, or even empty sets. In practise, sets are used to find out exactly for which objects to apply a given calculation step. In allocation network based calculations this is typically based on the allocation network. A very typical example is the set "all measured streams", which can then be used as a basis for the formulas that read metering data from the database.<br> The main purpose of sets is to make the calculations more generic and robust to configuration changes. As long as the underlying business rules stay the same, we don’t want to change the calculation when a new object is added, like a new well, a new metering point, a new owner, a new contract etc. By defining sets of objects based on their characteristics, new objects can automatically be included in the calculations. This obviously only holds true as long as the new object should be treated the same way as existing ones – if not then the calculations must be modified to cater for the new rules.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Formulas and iterations:<br> The actual calculations to be performed are expressed as formulas, either in the special EC mathematical syntax or in Excel.<br> Sets and multi-dimensional variables play a role in both cases, as EC allows a single formula to actually work on many data elements. This is done by applying a formula to each object in a set, which in practise means iterating over the objects and calculating the formula for each object. This is very useful when many objects should get the same treatment.<br> It is especially important in allocation network based calculations, since this approach also allows the calculation to automatically adapt to changes in the infrastructure.<br> As a very simple example, the ownership of a metered stream could be split using a percentage split from a configuration screen. In a traditional calculation engine, like Excel, this would have to be set up as one formula for each owner. If a new owner was added, the calculations would need to be modified. In EC, the combination of the sets and the multi-dimensional variables allows us to express this in a single expression that is also robust to changes:<br> "for each owner, let the allocated volume for that owner equal the total measured volume on the stream times the ownership percentage for that owner on that stream". Here, "owners" is a set that automatically picks up any new owners; "total measured volume per stream" is a one-dimensional variable; "allocated volume per stream and owner" is a two-dimensional variable.</span></font></li></ol><h2><span style="font-size: 13.33px;">EQUATION CALCULATION TYPE</span></h2><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">An equation based calculation (or sub-calculation) consists of a list of mathematical formulas in the special EC syntax. Formulas are executed in the order they appear.</span></font></p><h3><span style="font-size: 13.33px;">The EC Syntax</span></h3><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">The EC syntax is specially designed to be efficient, compact and robust to configuration changes in the typical calculations that are needed in a complex calculation with lots of data. Each formula in the list consists of several elements:</span></font></p><ol><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Disable flag, which disables the entire formula. Typically used during development and/or testing.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Documentation area, where a textual description of the formula can be entered. This textual description will also be included in the generated HTML documentation for the calculation.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">An optional list of <em>iterations</em>, which each consists of an <em>iterator</em> and a <em>set</em>. When one or more iterations are given, the entire formula is repeated for each object (or combination of objects) in the sets. More information about this is given below.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">An optional condition used to fine-tune when, and for which objects, a formula is run. If the formula has iterations then the condition is evaluated for each object (or combination of objects).</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">The actual formula; in most cases this will calculate a value and assign it to a variable, but there are also some special cases like log statements or flow control (loops etc).</span></font></li></ol><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">The basic EC formula is simply a mathematical statement that calculates a new value for a variable based on various operands, like the existing value of one or more variables, constant numbers, object attributes etc. The syntax supports a variety of mathematical operations, ranging from the simple operations like addition, subtraction, multiplication and division to more complex mathematical functions like min, max, exponentials, logarithms etc.</span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">A very simple example is to calculate the total production as the sum of oil production and gas production: "TotalProduction = OilProduction + GasProduction". This formula assumes that there is already a value in the variables OilProduction and GasProduction, and calculates a value for the TotalProduction variable.</span></font><font face="Arial, Verdana"><span style="font-size: 13.33px;"><br></span></font></p><h3><span style="font-size: 13.33px;">Iterations and Variable Dimensions</span></h3><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">The simple example above calculated the total production as the sum of oil and gas production. It does, however, raise one question: The total production for what? A platform? Or a plant? Or maybe a single well?</span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">Let’s assume that this calculation is done for a well, and that it should actually be carried out for each well in the system. In this case we can use an iteration to tell EC to repeat the formula for all wells: "for each well, calculate TotalProduction = OilProduction + GasProduction". However, EC requires us to be a little bit more specific, as it still doesn’t know exactly what we mean. We actually need to specifically tell it that we mean the production <em>for that well</em>, i.e. "for each well, calculate the TotalProduction (for the well) = OilProduction (for the well) + GasProduction (for the well)".&nbsp;<span lang="EN-GB" style='font-family: "Arial","sans-serif"; font-size: 10pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: "Times New Roman"; mso-bidi-font-family: "Times New Roman"; mso-ansi-language: EN-GB; mso-fareast-language: EN-US; mso-bidi-language: AR-SA;'>In the EC syntax, this is written as:</span></span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;"><span lang="EN-GB" style='font-family: "Arial","sans-serif"; font-size: 10pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: "Times New Roman"; mso-bidi-font-family: "Times New Roman"; mso-ansi-language: EN-GB; mso-fareast-language: EN-US; mso-bidi-language: AR-SA;'><todo: screenshot="" insert=""></todo:></span></span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;"><img src="/onlinehelp/img?type=description&amp;bfDescNo=CO.1040&amp;imgNo=1&amp;dataLevel=0&amp;pfdrid_c=true" class="ecImg"></span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;"><span lang="EN-GB" style='font-family: "Arial","sans-serif"; font-size: 10pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: "Times New Roman"; mso-bidi-font-family: "Times New Roman"; mso-ansi-language: EN-GB; mso-fareast-language: EN-US; mso-bidi-language: AR-SA;'>This example includes two very important

    concepts:</span></span></font></p><ol><li><font face="Arial, Verdana"><span style="font-size: 13.33px;"><span lang="EN-GB" style='font-family: "Arial","sans-serif"; font-size: 10pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: "Times New Roman"; mso-bidi-font-family: "Times New Roman"; mso-ansi-language: EN-GB; mso-fareast-language: EN-US; mso-bidi-language: AR-SA;'><span lang="EN-GB" style='font-family: "Arial","sans-serif"; font-size: 10pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: "Times New Roman"; mso-bidi-font-family: "Times New Roman"; mso-ansi-language: EN-GB; mso-fareast-language: EN-US; mso-bidi-language: AR-SA;'>The <i style="mso-bidi-font-style: normal;">iteration</i>

    over wells:<br>

    The iteration again consists of two elements, the <i style="mso-bidi-font-style: normal;">iterator</i> (w in the example) and the <i style="mso-bidi-font-style: normal;">set</i> (wells in the example). Also note the symbol </span><span lang="EN-GB" style='font-family: Symbol; font-size: 10pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: "Times New Roman"; mso-bidi-font-family: "Times New Roman"; mso-ansi-language: EN-GB; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-char-type: symbol; mso-symbol-font-family: Symbol;'><span style="mso-char-type: symbol; mso-symbol-font-family: Symbol;">Î</span></span><span lang="EN-GB" style='font-family: "Arial","sans-serif"; font-size: 10pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: "Times New Roman"; mso-bidi-font-family: "Times New Roman"; mso-ansi-language: EN-GB; mso-fareast-language: EN-US; mso-bidi-language: AR-SA;'> which is the mathematical symbol for elements

    of a set.<br>

    What the iteration actually does is to look up the content of the set (wells)

    and run the equation for each object in the set. Each time the equation is run,

    it assigns the current object (i.e. current well) to the iterator so that it

    can be used in the equation. So the w should be read as "current well" in our

    example.<br>

    In our example we use a set that contains all objects of a given type (i.e.

    wells), but the sets can and will often be more sophisticated, to apply the

    formula only to a sub-set of objects based on various criteria.</span></span></span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;"><span lang="EN-GB" style='font-family: "Arial","sans-serif"; font-size: 10pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: "Times New Roman"; mso-bidi-font-family: "Times New Roman"; mso-ansi-language: EN-GB; mso-fareast-language: EN-US; mso-bidi-language: AR-SA;'><span lang="EN-GB" style='font-family: "Arial","sans-serif"; font-size: 10pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: "Times New Roman"; mso-bidi-font-family: "Times New Roman"; mso-ansi-language: EN-GB; mso-fareast-language: EN-US; mso-bidi-language: AR-SA;'><span lang="EN-GB" style='font-family: "Arial","sans-serif"; font-size: 10pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: "Times New Roman"; mso-bidi-font-family: "Times New Roman"; mso-ansi-language: EN-GB; mso-fareast-language: EN-US; mso-bidi-language: AR-SA;'>Variable dimension and variable value

    addressing:<br>

    Note the syntax where the variable has a subscript. This means that the

    variables have a dimension; in our example all three variables are indexed by

    well. So instead of just storing a single value, the variables actually store a

    value for each well. All references to these variables must then include the

    subscript to tell the system which value (i.e. which well) we actually want to

    use.<br>

    Our example uses the iterator to access the data. This is a very common way of

    accessing variable data, but it is also possible to use other ways of picking

    out the "current object".</span></span></span></span></font></li></ol><font face="Arial, Verdana"><span style="font-size: 13.33px;"><span lang="EN-GB" style='font-family: "Arial","sans-serif"; font-size: 10pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: "Times New Roman"; mso-bidi-font-family: "Times New Roman"; mso-ansi-language: EN-GB; mso-fareast-language: EN-US; mso-bidi-language: AR-SA;'><span lang="EN-GB" style='font-family: "Arial","sans-serif"; font-size: 10pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: "Times New Roman"; mso-bidi-font-family: "Times New Roman"; mso-ansi-language: EN-GB; mso-fareast-language: EN-US; mso-bidi-language: AR-SA;'><span lang="EN-GB" style='font-family: "Arial","sans-serif"; font-size: 10pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: "Times New Roman"; mso-bidi-font-family: "Times New Roman"; mso-ansi-language: EN-GB; mso-fareast-language: EN-US; mso-bidi-language: AR-SA;'></span></span></span><p><span lang="EN-GB" style='font-family: "Arial","sans-serif"; font-size: 10pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: "Times New Roman"; mso-bidi-font-family: "Times New Roman"; mso-ansi-language: EN-GB; mso-fareast-language: EN-US; mso-bidi-language: AR-SA;'>In the previous example, the entire formula was

    repeated for each well. Another common usage of iterations is to do aggregation

    etc across objects or across time. Actually, EC treats time the same way as

    objects, by defining each day, each month etc as "objects". In the case of

    aggregations, the iteration is used within the equation itself:</span></p><p><span lang="EN-GB" style='font-family: "Arial","sans-serif"; font-size: 10pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: "Times New Roman"; mso-bidi-font-family: "Times New Roman"; mso-ansi-language: EN-GB; mso-fareast-language: EN-US; mso-bidi-language: AR-SA;'><img src="/onlinehelp/img?type=description&amp;bfDescNo=CO.1040&amp;imgNo=2&amp;dataLevel=0&amp;pfdrid_c=true" class="ecImg"></span></p><p><span lang="EN-GB" style='font-family: "Arial","sans-serif"; font-size: 10pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: "Times New Roman"; mso-bidi-font-family: "Times New Roman"; mso-ansi-language: EN-GB; mso-fareast-language: EN-US; mso-bidi-language: AR-SA;'>This example calculates the monthly production,

    for each well, as the sum of the daily production. Notice that the variables

    now have two dimensions, well and date. Also note that we have a dimension for

    the "current month". The reason for this is that EC as such has data for all months,

    and there is no automatic assumption that we actually mean the current month.

    This is to allow more flexibility, as there are some rare cases where a

    calculation needs to access data outside of the current day/month. A good

    example is stocks, where the closing stock for the previous period could be

    used as the opening stock for the current period.</span><br></p></span></font><h3><span style="font-size: 13.33px;">The Formula Editor</span></h3><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">The iteration, condition and equation parts are all edited by clicking the popup icon, which will open the formula editor. The formula editor allows you to modify the formula through a right-click context menu and/or shortcuts. The available shortcuts are indicated in the context menu.</span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">The context menu contains various operations and mathematical expressions, for example:</span></font></p><ol><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Operations like copy, paste, delete, etc.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Inserting operands into the formula. By operands we basically mean data – anything from constants to variables, object attributes, etc.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Inserting arithmetic operators and functions, from the basic operators like addition to more complex mathematical functions.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Inserting set operators and functions, used to manipulate sets of objects.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Inserting logical operators and functions, which are typically used in conditions.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Inserting date functions.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Inserting special constructs that has to do with logging, looping, etc.</span></font></li></ol><h2><span style="font-size: 13.33px;">WORKBOOK CALCULATION TYPE</span></h2><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">An Excel workbook based calculation consists of an Excel spreadsheet template. The template can contain any number of sheets, and can use the standard Excel formulas and formatting capabilities (note that formulas may only refer to cells and ranges within the template itself; they cannot contain links to other workbooks). A template workbook contains/defines the actual calculation formulae. The data values in the template are "sample" data, which will be replaced by actual values when the template is executed. The template must contain one or more mapping sheets (prefixed with "EC"). The mapping sheets tell the engine how to replace the sample data with actual EC values, and how to map result values back to EC.</span></font><font face="Arial, Verdana"><span style="font-size: 13.33px;"><br></span></font></p><h3><span style="font-size: 13.33px;">Workbook Template and Data Mappings</span></h3><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">During execution, the calculation engine will go through a series of steps:</span></font></p><ol><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">The workbook template is read and the data mappings are analyzed.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">The sample data in the template is replaced by the actual data from variables etc, as defined by the mappings.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">The workbook is refreshed (i.e. all formulas are recalculated).</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Outputs are read from the refreshed workbook and stored back to variables, as defined by the mappings.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">The refreshed workbook might be stored for log purposes, depending on the log profile used during execution.</span></font></li></ol><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">The mappings between the sample data in the template and the actual data in variables etc are the key element to configuring an Excel workbook based calculation. The most common mappings work with variables, either retrieving an existing value or storing a new result back to a variable. There are also other mappings to pull various data into the workbook or retrieve information back from the workbook, including error handling etc.</span></font><font face="Arial, Verdana"><span style="font-size: 13.33px;"><br></span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">A full list of the available mappings, examples and documentation of them is included in the "EC" sheet in the default Excel template.</span></font><font face="Arial, Verdana"><span style="font-size: 13.33px;"><br></span></font></p><h3><span style="font-size: 13.33px;">Static vs. Dynamic Mappings</span></h3><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">The most important concept to be aware of is static vs. dynamic mappings.</span></font><font face="Arial, Verdana"><span style="font-size: 13.33px;"><br></span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">In a static variable mapping, a single cell in the template workbook is mapped to a single variable value. Note that this really means a single value. For instance, if a variable contains oil production for wells then the mapping has to point to a specific well. This must then be repeated for each well, so that there is actually one mapping for each well. The same is true for all dimensions on a variable; the mapping has to be very explicit about which objects to use.</span></font><font face="Arial, Verdana"><span style="font-size: 13.33px;"><br></span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">The biggest advantage of this approach is that it very intuitive and it gives a very clear separation between the workbook structure, formulas etc and the data mappings. The workbook can be built without even knowing it will be used by EC, and then individual cells are mapped to EC as needed. The drawback, however, is that it doesn’t adapt to configuration changes. So, in our example, adding a new well to the system means that the template workbook must also be updated and new mappings added.</span></font><font face="Arial, Verdana"><span style="font-size: 13.33px;"><br></span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">The alternative is to use dynamic (also called range) mappings. In a dynamic mapping, a range of cells in the workbook is mapped to a "range" of variable values. This is done through a combination of sets and multi-dimensional variables. To use the same example as for the static mapping, we will consider a workbook that needs the oil production for each well. In this case, a single dynamic mapping can map a range in the workbook to these values. A set must then be created that contains all the wells. In the mapping, the Well dimension of the variable is then linked to this set instead of giving it a fixed value. During execution, the engine will then take the value from the variable for each object in the set, and put those values into the specified range in the workbook.</span></font><font face="Arial, Verdana"><span style="font-size: 13.33px;"><br></span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">Dynamic mappings can put data along rows, columns or both (cross-tables). It is also possible to have the engine add rows and columns to the range as needed if the actual number of objects in the set exceeds the size of the specified range in the workbook.</span></font><font face="Arial, Verdana"><span style="font-size: 13.33px;"><br></span></font></p><h2><span style="font-size: 13.33px;">FLOWCHART CALCULATION TYPE</span></h2><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">A calculation of this type is only used to add structure to the calculation. The calculation consists of a flowchart that breaks the calculation into a sequence of sub-calculations, where all the actual processing is performed.</span></font><font face="Arial, Verdana"><span style="font-size: 13.33px;"><br></span></font></p><h3><span style="font-size: 13.33px;">Flowchart Structure</span></h3><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">The flowchart consists of three elements:</span></font></p><ol><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Calculation steps: These are visualised as rectangular boxes, and link to sub-calculations to be performed. There are two special steps, Start and Stop that indicates the initiation and termination of the calculation.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Decision points: These are visualised as diamonds, and are used to conditionally select what the next calculation step should be.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Process transitions: These are visualised as arrows from one calculation step/decision point to another, and are used to model the calculation sequence (i.e. what the next calculation step should be).</span></font></li></ol><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">Elements are maintained through a right-click context menu that has options for adding, deleting, copying etc. All elements also have a name and/or comments field that show up in the right-hand part of the screen when the object is selected. We encourage the use of long descriptive names and good comments, as these are used both in the screen and in the generated documentation. Descriptive names and useful comments are also useful during a design phase, and are crucial to the maintainability of the calculation after it is completed.</span></font></p><h3><span style="font-size: 13.33px;">Sub-Calculation Types</span></h3><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">Each sub-calculation (including decision points) can be any of four types, which is also indicated by an icon in the upper right corner:</span></font></p><ol><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Equation based calculation, indicated by a sigma sign in the icon.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Excel workbook based calculation, indicated by an excel icon.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">A new flowchart, indicated by a flowchart in the icon.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;"><span lang="EN-GB" style='font-family: "Arial","sans-serif"; font-size: 10pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: "Times New Roman"; mso-bidi-font-family: "Times New Roman"; mso-ansi-language: EN-GB; mso-fareast-language: EN-US; mso-bidi-language: AR-SA;'>A call to a separately defined library

    calculation, indicated by a process cogwheel in the icon.</span></span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Not decided yet, indicated by the lack of any icon and a dotted frame.</span></font></li></ol><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">Since the sub-calculations can also be flowchart based, it is possible to build flowchart hierarchies with any number of levels and let the users drill into more and more details. Implementers are encouraged to try and match the number of levels to the complexity of the calculation. The top level should be fairly easy to understand for almost any user with basic business and/or system knowledge. Drilling into lower levels will require more and more detailed knowledge, but at the same time the drill-down approach gives more context to each sub-calculation. This should make it easier to understand and maintain calculations after they are implemented. Descriptive names and useful comments are also encouraged to make the calculation more understandable and maintainable.</span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">For a multi-level flowchart, the current location or "path" is shown in the screen and updated whenever one drills into or moves back up from a sub-calculation.</span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">The option of not deciding what type a sub-calculation should be is useful during design and early implementation work. The flowchart can be built at a high level first, and the actual decision on whether or not to break it up further with another level of flowcharts etc can be made later after further analysis.</span></font></p><h3><span style="font-size: 13.33px;">Decision Points</span></h3><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">Decision points are implemented just as the same as any other sub-calculation, except for two small but important differences.</span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">First, a decision point implementation must at some point assign a value to a special predefined variable called <em>DecisionValue</em>. This variable has no dimensions and is of data type String, which means that it should be assigned a single textual value.</span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">Exactly how to assign to this variable depends on the type of calculation:</span></font></p><ol><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">In equation based calculations, this variable is not found through the normal <em>Insert variable</em> option in the context menu. Instead it is inserted into the formula through a separate context menu option under the <em>Flow Control</em> sub-menu.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">In Excel workbook based calculations, this variable is assigned to by creating a normal static mapping with <em>DecisionValue</em> as the variable name.</span></font></li></ol><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">The second difference is that a decision point should have more than one outgoing transition (line to other elements). Each outgoing transition should have a Decision Value given (input in the right-hand section of the screen when the transition is selected). All outgoing transitions must have distinct decision values, and it is possible to have one with a blank decision value. The set of decision values used on the transitions should match the possible values assigned to the <em>DecisionValue</em> variable by the sub-calculation.</span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">During execution, the engine will first execute the sub-calculation that implements the decision point. It will then analyse the value of the <em>DecisionValue</em> variable, and compare this to the Decision Value of the outgoing transitions. If a match is found then that transition is used to determine the next calculation step. If there are no matches, then the transition with blank decision value is used if there is one. If there are no transitions that match, and no transition with blank decision value, then the calculation fails.</span></font></p><h3><span style="font-size: 13.33px;">Calculation Step Iterations</span></h3><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">It is possible to add iterations to calculation steps. This will cause the entire sub-calculation to be executed multiple times.</span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">Iterations are added in the right-hand section of the screen when the calculation step is selected. Iterations consist of an iterator name and an object set. The sub-calculation will be repeated once for each object in the set. The iterator name can be used within the sub-calculation to access the "current object", for instance in local set definitions and in formulas.</span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">Object sets are sorted, and the sub-calculation will be executed in the order given by the set. This gives control over not only which objects to repeat the calculation for, but also the sequence.</span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">It is possible to have multiple iterations on the same calculation step. In this case, the sub-calculation is executed for each combination of objects from the sets. Please note, however, that iterations on calculation steps can make it harder to read the calculation, and also results in larger and potentially harder to read log files. We therefore recommend using as few iterations of this type as possible, even though there is no technical limitation to the number of iterations that can be applied to a calculation step.</span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">Iterations on calculation steps are always executed exactly once for each object (or combination of objects) from the set(s). To create more conditional looping, use decision points instead of iterations. In this case, local variables for "current set index", "current object" etc can also be used if needed.</span></font></p><h3><span style="font-size: 13.33px;">Library Calculations</span></h3><p><span style="font-size: 13.33px;"><span lang="EN-GB" style='font-family: "Arial","sans-serif"; font-size: 10pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: "Times New Roman"; mso-bidi-font-family: "Times New Roman"; mso-ansi-language: EN-GB; mso-fareast-language: EN-US; mso-bidi-language: AR-SA;'>It is possible to implement a sub-calculation

    (both regular steps and decision points) by linking it to a library

    calculation. Library calculations are maintained separately from the main

    calculation, and can be reused from multiple process steps and/or multiple

    calculations. Library calculations are defined in <i style="mso-bidi-font-style: normal;"><span style="mso-bookmark: OLE_LINK14;"><span style="mso-bookmark: OLE_LINK15;">CO.1061 –

    Create Library Calculation</span></span></i>, and maintained in <i style="mso-bidi-font-style: normal;">CO.1062 – Maintain Library Calculations</i>.

    You select the library calculation to link to in a separate page that opens

    when you drill into the process step.</span></span></p><p></p><span style="font-size: 13.33px;"><p></p><span lang="EN-GB" style='font-family: "Arial","sans-serif"; font-size: 10pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: "Times New Roman"; mso-bidi-font-family: "Times New Roman"; mso-ansi-language: EN-GB; mso-fareast-language: EN-US; mso-bidi-language: AR-SA;'><p></p><span lang="EN-GB" style='font-family: "Arial","sans-serif"; font-size: 10pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: "Times New Roman"; mso-bidi-font-family: "Times New Roman"; mso-ansi-language: EN-GB; mso-fareast-language: EN-US; mso-bidi-language: AR-SA;'><p>Library calculations inherit the sets, variables

    and iterators from the calling calculation(s). If the library calculation uses

    any inherited sets or variables, then this will be defined in <i style="mso-bidi-font-style: normal;">CO.1061 – Create Library Calculation</i>.

    This information will also be shown when you drill into a library calculation

    step. If you link to a library calculation then it is important to make sure

    that you have the right sets, variables and iterators defined:</p><ol><li>Make sure that you have defined all local sets to be passed on to the library calculation.</li><ol><li>The exact list of sets is listed in the library call details (or in the Create Library Calculation screen).</li><li>The sets need to be named exactly as expected, and be defined in a parent step of the call.</li><li>The sets can’t be changed by the library calculation; they are only used to pass information to the library calculation.</li></ol><li>Make sure that you have defined all local variables to be passed on to the library calculation.</li><ol><li>The exact list of variables is listed in the library call details (or in the Create Library Calculation screen).</li><li>The variables need to have the exact same signature as expected, and be defined in a parent step of the call.</li></ol><li>Handle variable values being passed to/from the library calculation.</li><ol><li>Variables (both global and local) can be resolved and/or assigned by both calculations.</li><li>This can used to pass input data to the library calculation, and/or retrieve outputs.</li><li>In many cases you might need to prepare or react to these data in steps before or after the library call.</li><li>The library calculation description should contain information about any shared variables.</li></ol><li>Add iterators to be passed on to the library calculation.</li><ol><li>The exact list of iterators is not directly available, but should be in the library calculation description.</li><li>The iterators need to be named exactly as expected, and be defined on the call step itself or on a parent step.</li><li>The iterators can’t be changed by the library calculation; they are only used to pass information to the library calculation.</li></ol></ol>

    <h2><span style="font-size: 13.33px;">SETS (LOCAL AND INHERITED)</span></h2><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">Sets are used to define groups of objects that are used in the calculations. The most common usage of sets is either to apply a calculation step or formula to each object with a single statement, or to do aggregations etc across the objects in the set.</span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">Sets are normally defined through conditional expressions rather than listing specific objects. This makes the calculations much more robust and independent of configuration changes. As new objects are added, or old ones removed, the sets are expressed such that they always pick up the relevant objects based on the current configuration.</span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">As an example, a calculation might need to calculate something for each owner in an operation. Instead of hard-coding the list of owners, it makes more sense to dynamically create the list based on configuration that is already in the system. In our example we might want to define the set of owners to be "all companies that have an ownership percentage &gt; 0%". By using this type of expressions, the calculations will still work even if the configuration changes.</span></font><font face="Arial, Verdana"><span style="font-size: 13.33px;"><br></span></font></p><h3><span style="font-size: 13.33px;">Set types</span></h3><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">There are four different types of set definitions:</span></font></p><ol><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Database Object Type sets:<br> This is the most basic set type, and gives access to all objects of a given type. Typical examples are all Streams, all Companies and all Contracts. In most cases sets of this type are not used directly, but rather form the basis for more sophisticated sets.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Filtered sets:<br> A filtered set contains a subset of the elements in another set, called the base set. A filtered set must identify the base set and a filtering condition. Any element that is in the base set and that satisfies the filtering condition will be included in the filtered set. The filtering condition typically involves comparison of object attributes against given values. A typical example of a filtered set is the "set of all metered streams". This set may have the "set of all streams" as its base set, and Stream Type = M (for Measured) as its filtering condition. Another example is the set of "all sales contracts" with the "all contracts" as base set and Contract Type = Sale as filtering condition. Note that the base set does not have to be a Database Object Type set. It can be a previously defined filtered set, combination or equation set, so sets can become more and more specialised by using the previous definitions as starting point for new one.</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Combination sets:<br> Similar to a filtered set, a combination set also creates new sets based on existing sets. But in a combination set this is done by combining two or more sets. The new set is then built by combining the sets in various ways, for instance adding or subtracting them. A typical example is to find all streams that are <em>not</em> measured as "all streams minus measured streams".</span></font></li><li><font face="Arial, Verdana"><span style="font-size: 13.33px;">Equations based sets:<br> This is the most flexible way of defining sets, and can use the full flexibility of the EC calculation engine. It is possible to define virtually any set using this syntax, including all of the other set types. The drawback is that equation sets require knowledge of the mathematical syntax used by EC formulas. This syntax is probably known anyway when the EC syntax is used for expressing the calculation itself, but if the Excel Workbook approach is used then it requires some additional knowledge to use equation based sets.</span></font></li></ol><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">It is of course possible to mix all set types freely. In most sets, object types and object attributes play an important role. Database object types and their attributes are defined in the BF <em>Database Object Types (CO.1037)</em>.</span></font></p><h3><span style="font-size: 13.33px;">Set Scope and Set Inheritance</span></h3><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">Sets are defined in the <em>Local Sets</em> tab and are visible in the calculations that define them. In flowchart calculations, however, they are also visible in all sub-calculations. A set that is visible in a calculation but that is defined by a parent is called an inherited set. Inherited sets are listed in the <em>Inherited Sets</em> tab.</span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">Note that inheritance doesn’t stop after one level. If a sub-calculation is also of the flowchart type, then any sets that it inherited from its parent will also be visible in its sub-calculations. This basically means that a set is valid from the point where it is defined and "downwards". The <em>Inherited Sets</em> tab will thus list all sets defined in the immediate parent, the grandparent etc all the way up to the root calculation.</span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">Set inheritance can be very useful to make sure that sets are only visible to the parts of the calculation that actually needs them. This reduces the list of sets visible in any given sub-calculation to only contain sets that are relevant. On the other hand, spreading the set definitions in too many sub-calculations might make it harder to keep track of them and you might end up defining the same set several places. A proper balance must therefore be found between defining sets on a high level and letting all sub-calculations inherit them, versus defining them on a local level as they are needed.</span></font><font face="Arial, Verdana"><span style="font-size: 13.33px;"><br></span></font></p><h2><span style="font-size: 13.33px;">VARIABLES (LOCAL AND INHERITED)</span></h2><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">Variables are used to hold the data in the calculations.</span></font></p><h3><span style="font-size: 13.33px;">Local Variables and Variable Inheritance</span></h3><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">Local variables are defined within a calculation, in the <em>Local Variables</em> tab. Local variables are used purely to hold intermediate results in the calculation. If they are defined in a calculation of the flowchart type, however, then they are also valid in all sub-calculations. Such variables that are available in a calculation but are really defined in a parent calculation are called inherited variables, and are listed in the <em>Inherited Variables</em> tab.</span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">Note that inheritance doesn’t stop after one level. If a sub-calculation is also of the flowchart type, then any variables that it inherited from its parent are also available for its sub-calculations. This basically means that a variable is valid from the point where it is defined and "downwards". The <em>Inherited Variables</em> tab will thus list all variables defined in the immediate parent, the grandparent etc all the way up to the root calculation.</span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">Variable inheritance can be very useful to make sure that variables are only visible to the parts of the calculation that actually needs them. This reduces the list of variables visible in any given sub-calculation to only contain variables that are relevant. On the other hand, spreading the variable definitions in too many subcalculations might make it harder to keep track of them and you might end up defining the same variable several places. A proper balance must therefore be found between defining variables on a high level and letting all sub-calculations inherit them, versus defining them on a local level as they are needed.</span></font></p><h3><span style="font-size: 13.33px;">Global Variables</span></h3><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">Global variables are defined against the calculation context, and are valid for all calculations and sub-calculations within the context. Global variables are listed in the Inherited Variables tab but have the context name in the Inherited From column.</span></font></p><p><font face="Arial, Verdana"><span style="font-size: 13.33px;">The most common use of global variables is to read from or write data to the EC database. Global variables are defined in the BF <em>Variable Definitions (CO.1039)</em>.</span></font></p>

    </span></span></span>
related: {}
